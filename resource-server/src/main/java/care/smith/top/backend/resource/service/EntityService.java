package care.smith.top.backend.resource.service;

import care.smith.top.backend.model.Expression;
import care.smith.top.backend.model.*;
import care.smith.top.backend.neo4j_ontology_access.model.Class;
import care.smith.top.backend.neo4j_ontology_access.model.Repository;
import care.smith.top.backend.neo4j_ontology_access.model.*;
import care.smith.top.backend.neo4j_ontology_access.repository.*;
import care.smith.top.backend.resource.util.ApiModelMapper;
import care.smith.top.phenotype2r.Phenotype2RConverter;
import org.neo4j.cypherdsl.core.*;
import org.springframework.beans.PropertyAccessor;
import org.springframework.beans.PropertyAccessorFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.time.ZoneOffset;
import java.util.Set;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class EntityService implements ContentService {
  @Value("${spring.paging.page-size:10}")
  private int pageSize;

  @Autowired private ClassRepository classRepository;
  @Autowired private ClassVersionRepository classVersionRepository;
  @Autowired private AnnotationRepository annotationRepository;
  @Autowired private ExpressionRepository expressionRepository;
  @Autowired private RepositoryRepository repositoryRepository;

  public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
    Set<Object> seen = ConcurrentHashMap.newKeySet();
    return t -> seen.add(keyExtractor.apply(t));
  }

  private static Statement findEntitiesMatchingConditionStatement(
      String repositoryId,
      String name,
      List<EntityType> type,
      DataType dataType,
      boolean primaryOnly,
      Integer page) {
    /*
     * It would be better to use autogenerated node classes here, but there is currently a bug that
     * prevents instantiation of our model. See:
     * https://github.com/neo4j-contrib/cypher-dsl/issues/335
     */
    Node c = Cypher.node("Class").named("c");
    Node cv = Cypher.node("ClassVersion").named("cv");
    Node a = Cypher.node("Annotation").named("a");
    Node r = Cypher.node("Repository").named("r");
    Node aTitle = a.withProperties("property", Cypher.anonParameter("title")).named("title");
    Node aSynonym = a.withProperties("property", Cypher.anonParameter("synonym")).named("synonym");
    Node aDataType =
        a.withProperties("property", Cypher.anonParameter("dataType")).named("dataType");
    Relationship cRel = cv.relationshipTo(c, "IS_VERSION_OF").named("cRel");
    NamedPath p1 = Cypher.path("p1").definedBy(cv.relationshipTo(a, "HAS_ANNOTATION").unbounded());
    NamedPath p2 =
        Cypher.path("p2").definedBy(a.relationshipTo(Cypher.node("Class"), "HAS_CLASS_VALUE"));

    Condition typeCondition = Conditions.noCondition();
    if (type != null) {
      for (EntityType t : type) {
        typeCondition = typeCondition.or(c.hasLabels(t.getValue()));
      }
    }

    return Cypher.match(c.relationshipTo(cv, "CURRENT_VERSION"))
        .match(cRel)
        .match(r)
        .where(typeCondition)
        .and(
            primaryOnly
                ? r.property("id")
                    .isEqualTo(c.property("repositoryId"))
                    .and(r.property("primary").isEqualTo(Cypher.literalTrue()))
                : Cypher.literalTrue().asCondition())
        .and(
            repositoryId != null
                ? c.property("repositoryId").isEqualTo(Cypher.anonParameter(repositoryId))
                : Cypher.literalTrue().asCondition())
        .optionalMatch(cv.relationshipTo(aTitle, "HAS_ANNOTATION"))
        .optionalMatch(cv.relationshipTo(aSynonym, "HAS_ANNOTATION"))
        .optionalMatch(cv.relationshipTo(aDataType, "HAS_ANNOTATION"))
        .with(
            c.getRequiredSymbolicName(),
            cRel.getRequiredSymbolicName(),
            cv.getRequiredSymbolicName(),
            aTitle.getRequiredSymbolicName(),
            aSynonym.getRequiredSymbolicName(),
            aDataType.getRequiredSymbolicName())
        .where(Cypher.literalTrue().asCondition())
        .and(
            name != null
                ? Functions.toLower(aTitle.property("stringValue"))
                    .contains(Cypher.anonParameter(name.toLowerCase()))
                    .or(
                        Functions.toLower(aSynonym.property("stringValue"))
                            .contains(Cypher.anonParameter(name.toLowerCase())))
                : Cypher.literalTrue().asCondition())
        .and(
            dataType != null
                ? aDataType
                    .property("stringValue")
                    .isEqualTo(Cypher.anonParameter(dataType.getValue()))
                : Cypher.literalTrue().asCondition())
        .with(cv, Functions.collect(cRel).as("cRel"), Functions.collect(c).as("c"))
        .optionalMatch(p1)
        .optionalMatch(p2)
        .returning(
            cv.getRequiredSymbolicName(),
            cRel.getRequiredSymbolicName(),
            c.getRequiredSymbolicName(),
            Functions.collect(Functions.nodes(p1)),
            Functions.collect(Functions.relationships(p1)),
            Functions.collect(Functions.nodes(p2)),
            Functions.collect(Functions.relationships(p2)))
        .build();
  }

  @Override
  public long count() {
    return classRepository.count();
  }

  public long count(EntityType... types) {
    Node cls = Cypher.node("Class").named("class");
    Condition condition = cls.isNull();
    for (EntityType t : types) {
      condition = condition.or(cls.hasLabels(t.getValue()));
    }
    return classRepository.count(condition);
  }

  @Transactional
  public Entity createEntity(String organisationId, String repositoryId, Entity entity) {
    if (classRepository.existsById(entity.getId()))
      throw new ResponseStatusException(HttpStatus.CONFLICT);
    getRepository(organisationId, repositoryId);

    if (entity.getEntityType() == null)
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "entityType is missing");

    Class cls = new Class(entity.getId());
    cls.setRepositoryId(repositoryId);
    cls.setCurrentVersion(buildClassVersion(entity, repositoryId).setVersion(1));
    cls.addType(entity.getEntityType().getValue());

    List<String> superClasses = new ArrayList<>();
    if (entity instanceof Category) {
      Category category = (Category) entity;
      if (category.getSuperCategories() != null)
        superClasses.addAll(
            category.getSuperCategories().stream().map(Entity::getId).collect(Collectors.toList()));
    }

    if (entity instanceof Phenotype) {
      Phenotype phenotype = (Phenotype) entity;
      if (phenotype.getSuperPhenotype() != null)
        superClasses.add(phenotype.getSuperPhenotype().getId());
    }

    if (!superClasses.isEmpty()) {
      superClasses.forEach(
          c -> {
            Class superClass =
                classRepository
                    .findByIdAndRepositoryId(c, repositoryId)
                    .orElseThrow(
                        () ->
                            new ResponseStatusException(
                                HttpStatus.NOT_FOUND,
                                String.format("Super class '%s' does not exist!", c)));
            cls.addSuperClassRelation(
                new ClassRelation(superClass, repositoryId, entity.getIndex()));
          });
    }

    return classToEntity(classRepository.save(cls), repositoryId);
  }

  @Transactional
  public List<Entity> createFork(
      String organisationId,
      String repositoryId,
      String id,
      ForkCreateInstruction forkCreateInstruction,
      Integer version,
      List<String> include) {
    if (repositoryId.equals(forkCreateInstruction.getRepositoryId()))
      throw new ResponseStatusException(
          HttpStatus.NOT_ACCEPTABLE,
          String.format("Cannot create fork of entity '%s' in the same repository.", id));

    Repository originRepo = getRepository(organisationId, repositoryId);

    if (!originRepo.isPrimary())
      throw new ResponseStatusException(
          HttpStatus.NOT_ACCEPTABLE,
          String.format(
              "Cannot create fork of entity '%s' from non-primary repository '%s'.",
              id, originRepo.getId()));

    Repository destinationRepo =
        getRepository(
            forkCreateInstruction.getOrganisationId(), forkCreateInstruction.getRepositoryId());

    Entity entity = loadEntity(organisationId, repositoryId, id, null);

    List<Entity> origins = new ArrayList<>();
    if (ApiModelMapper.isRestricted(entity)) {
      Entity superPhenotype =
          loadEntity(
              organisationId, repositoryId, ((Phenotype) entity).getSuperPhenotype().getId(), null);
      origins.add(superPhenotype);
      origins.add(entity);
    } else {
      origins.add(entity);
      origins.addAll(getSubclasses(organisationId, repositoryId, origins.get(0).getId(), null));
    }

    List<Entity> results = new ArrayList<>();
    for (Entity origin : origins) {
      String oldId = origin.getId();
      if (classRepository.forkExists(oldId, destinationRepo.getId())) continue;

      origin.setId(UUID.randomUUID().toString());
      origin.setVersion(1);

      if (origin instanceof Phenotype) {
        Phenotype phenotype = (Phenotype) origin;
        phenotype.setSuperCategories(null);
        if (phenotype.getSuperPhenotype() != null) {
          Optional<Class> superClass =
              classRepository.getFork(
                  phenotype.getSuperPhenotype().getId(), destinationRepo.getId());
          if (superClass.isEmpty()) continue;
          phenotype.setSuperPhenotype((Phenotype) new Phenotype().id(superClass.get().getId()));
        }
      } else {
        ((Category) origin).setSuperCategories(null);
      }

      results.add(
          createEntity(forkCreateInstruction.getOrganisationId(), destinationRepo.getId(), origin));

      classRepository.setFork(origin.getId(), oldId);
      ClassVersion forkVersion =
          classVersionRepository.findCurrentByClassId(origin.getId()).orElseThrow();
      classVersionRepository
          .findCurrentByClassId(oldId)
          .ifPresent(cv -> classVersionRepository.setEquivalentVersion(forkVersion, cv));
    }

    return results;
  }

  @Transactional
  public void deleteEntity(String organisationId, String repositoryId, String id) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));
    deleteClass(cls);
  }

  @Transactional
  public void deleteVersion(
      String organisationId, String repositoryId, String id, Integer version) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    ClassVersion classVersion =
        classVersionRepository
            .findByClassIdAndVersion(cls.getId(), version)
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    ClassVersion currentVersion =
        classVersionRepository
            .findCurrentByClassId(cls.getId())
            .orElseThrow(
                () ->
                    new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "Class does not have a current version."));

    if (classVersion.equals(currentVersion))
      throw new ResponseStatusException(
          HttpStatus.NOT_ACCEPTABLE, "Current version of a class cannot be deleted.");

    classVersionRepository
        .getNext(classVersion)
        .ifPresent(
            next ->
                classVersionRepository
                    .getPrevious(classVersion)
                    .ifPresent(cv -> classVersionRepository.setPreviousVersion(next, cv)));

    deleteAnnotations(classVersion);
    expressionRepository.deleteAll(classVersion.getExpressions());
    classVersionRepository.delete(classVersion);
  }

  public StringWriter exportEntity(
      String organisationId, String repositoryId, String id, String format, Integer version) {
    StringWriter writer = new StringWriter();
    Collection<Entity> entities =
        getEntitiesByRepositoryId(organisationId, repositoryId, null, null, null, null, null);
    if ("vnd.r-project.r".equals(format)) {
      Collection<Phenotype> phenotypes =
          entities.stream()
              .filter(e -> !EntityType.CATEGORY.equals(e.getEntityType()))
              .map(e -> (Phenotype) e)
              .collect(Collectors.toList());
      try {
        Phenotype2RConverter converter = new Phenotype2RConverter(phenotypes);
        Entity entity = loadEntity(organisationId, repositoryId, id, version);
        if (EntityType.CATEGORY.equals(entity.getEntityType())) {
          for (Entity subClass :
              getSubclasses(organisationId, repositoryId, id, null).stream()
                  .filter(e -> !EntityType.CATEGORY.equals(e.getEntityType()))
                  .collect(Collectors.toList())) {
            converter.convert(subClass.getId(), writer);
            writer.append(System.lineSeparator());
          }
        } else {
          converter.convert(id, writer);
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    } else {
      throw new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE);
    }
    return writer;
  }

  public List<Entity> getEntities(
      List<String> include, String name, List<EntityType> type, DataType dataType, Integer page) {
    int requestedPage = page != null ? page - 1 : 0;
    return classVersionRepository
        .findAll(
            findEntitiesMatchingConditionStatement(null, name, type, dataType, true, requestedPage),
            ClassVersion.class)
        .parallelStream()
        .flatMap(
            cv -> {
              String repositoryId = cv.getaClass().getRepositoryId();
              Entity entity = classVersionToEntity(cv, repositoryId);
              Stream<Entity> result = Stream.of(entity);
              if (type == null
                  || type.contains(ApiModelMapper.toRestrictedEntityType(entity.getEntityType())))
                result = Stream.concat(result, getChildren(cv.getaClass().getId(), repositoryId));
              return result;
            })
        .filter(distinctByKey(Entity::getId))
        .collect(Collectors.toList());
  }

  public List<Entity> getEntitiesByRepositoryId(
      String organisationId,
      String repositoryId,
      List<String> include,
      String name,
      List<EntityType> type,
      DataType dataType,
      Integer page) {
    getRepository(organisationId, repositoryId);
    int requestedPage = page != null ? page - 1 : 0;
    return classVersionRepository
        .findAll(
            findEntitiesMatchingConditionStatement(
                repositoryId, name, type, dataType, false, requestedPage))
        .parallelStream()
        .flatMap(
            cv -> {
              Entity entity = classVersionToEntity(cv, repositoryId);
              Stream<Entity> result = Stream.of(entity);
              if (type == null
                  || type.contains(ApiModelMapper.toRestrictedEntityType(entity.getEntityType())))
                result = Stream.concat(result, getChildren(cv.getaClass().getId(), repositoryId));
              return result;
            })
        .filter(distinctByKey(Entity::getId))
        .collect(Collectors.toList());
  }

  public ForkingStats getForkingStats(
      String organisationId, String repositoryId, String id, List<String> include) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    ForkingStats forkingStats = new ForkingStats();

    forkingStats.setForks(
        classRepository.getForks(cls.getId()).stream()
            .map(f -> classToEntity(f, repository.getId()))
            .collect(Collectors.toList()));

    classRepository
        .findOrigin(cls)
        .ifPresent(o -> forkingStats.origin(classToEntity(o, o.getRepositoryId())));

    return forkingStats;
  }

  public List<Entity> getRestrictions(String ownerId, Phenotype abstractPhenotype) {
    if (!ApiModelMapper.isAbstract(abstractPhenotype)) return new ArrayList<>();
    return classRepository
        .findSubclasses(abstractPhenotype.getId(), ownerId)
        .map(
            cls -> {
              Optional<Class> classVersion =
                  classRepository.findByIdAndRepositoryId(cls.getId(), ownerId);
              return classVersion.map(aClass -> classToEntity(aClass, ownerId)).orElse(null);
            })
        .filter(Objects::nonNull)
        .collect(Collectors.toList());
  }

  public List<Entity> getRootEntitiesByRepositoryId(
      String organisationId,
      String repositoryId,
      List<String> include,
      String name,
      List<EntityType> type,
      DataType dataType,
      Integer page) {
    Repository repository = getRepository(organisationId, repositoryId);
    return classRepository.findRootClassesByRepository(repository).stream()
        .map(c -> classToEntity(c, repository.getId()))
        .collect(Collectors.toList());
  }

  public List<Entity> getSubclasses(
      String organisationId, String repositoryId, String id, List<String> include) {
    Repository repository = getRepository(organisationId, repositoryId);
    return classRepository
        .findSubclasses(id, repository.getId())
        .map(
            c -> {
              Entity entity = null;
              try {
                entity = classToEntity(c, repository.getId());
              } catch (ResponseStatusException ignored) {
              }
              return entity;
            })
        .collect(Collectors.toList());
  }

  public List<Entity> getVersions(
      String organisationId, String repositoryId, String id, List<String> include) {
    Repository repository = getRepository(organisationId, repositoryId);
    return classVersionRepository
        .findByClassId(id, PageRequest.of(0, 10, Sort.Direction.DESC, "cv.version"))
        .stream()
        .parallel()
        .map(cv -> classVersionToEntity(cv, repositoryId))
        .collect(Collectors.toList());
  }

  public Entity loadEntity(String organisationId, String repositoryId, String id, Integer version) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    Optional<ClassVersion> optional;
    if (version == null) {
      optional = classVersionRepository.findCurrentByClassId(cls.getId());
    } else {
      optional = classVersionRepository.findByClassIdAndVersion(cls.getId(), version);
    }
    ClassVersion classVersion =
        optional.orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    return classVersionToEntity(classVersion, repositoryId);
  }

  public Entity setCurrentEntityVersion(
      String organisationId,
      String repositoryId,
      String id,
      Integer version,
      List<String> include) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    ClassVersion classVersion =
        classVersionRepository
            .findByClassIdAndVersion(id, version)
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    classRepository.setCurrent(cls, classVersion);

    return classToEntity(cls, repositoryId);
  }

  public Entity updateEntityById(
      String organisationId, String repositoryId, String id, Entity entity, List<String> include) {
    Repository repository = getRepository(organisationId, repositoryId);
    Class cls =
        classRepository
            .findByIdAndRepositoryId(id, repository.getId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    if (cls.getTypes() == null || !cls.getTypes().contains(entity.getEntityType().getValue()))
      throw new ResponseStatusException(HttpStatus.CONFLICT, "entityType does not match");

    ClassVersion newVersion =
        buildClassVersion(entity, repositoryId).setVersion(classRepository.getNextVersion(cls));
    cls.setCurrentVersion(newVersion);

    List<String> superClasses = new ArrayList<>();
    if (entity instanceof Category) {
      Category category = (Category) entity;
      if (category.getSuperCategories() != null)
        superClasses.addAll(
            category.getSuperCategories().stream()
                .filter(Objects::nonNull)
                .map(Entity::getId)
                .collect(Collectors.toList()));
    }

    if (entity instanceof Phenotype) {
      Phenotype phenotype = (Phenotype) entity;
      if (phenotype.getSuperPhenotype() != null)
        superClasses.add(phenotype.getSuperPhenotype().getId());
    }

    cls.setSuperClassRelations(
        superClasses.stream()
            .map(
                c -> {
                  if (cls.getId().equals(c)) return null;
                  Optional<Class> superClass =
                      classRepository.findByIdAndRepositoryId(c, repositoryId);
                  if (superClass.isEmpty()) return null;
                  return new ClassRelation(superClass.get(), repositoryId, entity.getIndex());
                })
            .filter(Objects::nonNull)
            .collect(Collectors.toSet()));

    Optional<ClassVersion> latestVersion = classVersionRepository.findLatestByClassId(cls.getId());

    Entity result = classToEntity(classRepository.save(cls), repositoryId);

    latestVersion.ifPresent((v) -> classVersionRepository.setPreviousVersion(newVersion, v));

    return result;
  }

  /**
   * Build a new {@link ClassVersion} object from an {@link Entity} object.
   *
   * @param entity The entity that provides data for the {@link ClassVersion} object fields.
   * @return The resulting {@link ClassVersion} object.
   */
  private ClassVersion buildClassVersion(Entity entity, String repositoryId) {
    ClassVersion classVersion = new ClassVersion();

    if (entity instanceof Phenotype) {
      Phenotype phenotype = (Phenotype) entity;
      if (phenotype.getScore() != null)
        classVersion.addAnnotation(
            new Annotation("score", phenotype.getScore().doubleValue(), null));
      if (phenotype.getDataType() != null)
        classVersion.addAnnotation(
            new Annotation("dataType", phenotype.getDataType().getValue(), null));
      if (phenotype.getUnit() != null)
        classVersion.addAnnotation(ApiModelMapper.toAnnotation(phenotype.getUnit()));
      if (phenotype.getRestriction() != null)
        classVersion.addAnnotation(fromRestriction(phenotype.getRestriction()));
      if (phenotype.getExpression() != null)
        classVersion.addAnnotation(fromExpression(phenotype.getExpression(), repositoryId));
    }

    if (entity.getCodes() != null)
      classVersion.addAnnotations(
          entity.getCodes().stream()
              .map(ApiModelMapper::toAnnotation)
              .filter(Objects::nonNull)
              .collect(Collectors.toList()));

    if (entity.getTitles() != null)
      classVersion.addAnnotations(
          entity.getTitles().stream()
              .map(t -> new Annotation("title", t.getText(), t.getLang()))
              .collect(Collectors.toList()));
    if (entity.getSynonyms() != null)
      classVersion.addAnnotations(
          entity.getSynonyms().stream()
              .map(s -> new Annotation("synonym", s.getText(), s.getLang()))
              .collect(Collectors.toList()));
    if (entity.getDescriptions() != null)
      classVersion.addAnnotations(
          entity.getDescriptions().stream()
              .map(d -> new Annotation("description", d.getText(), d.getLang()))
              .collect(Collectors.toList()));

    return classVersion;
  }

  /**
   * Transforms the given {@link Class} object's <u>current version</u> to an {@link Entity} object.
   * If corresponding class version was not loaded from DB, this method will try to load the current
   * version of the class.
   *
   * @param cls The {@link Class} object to be transformed.
   * @return The resulting {@link Entity} object.
   * @throws ResponseStatusException If the provided class has no current version.
   */
  private Entity classToEntity(Class cls, String ownerId) throws ResponseStatusException {
    ClassVersion current =
        cls.getCurrentVersion()
            .or(() -> classVersionRepository.findCurrentByClassId(cls.getId()))
            .orElseThrow(
                () ->
                    new ResponseStatusException(
                        HttpStatus.INTERNAL_SERVER_ERROR, "Entity had no version!"));

    return classVersionToEntity(current, ownerId);
  }

  /**
   * Transforms the given {@link ClassVersion} object to an {@link Entity} object.
   *
   * @param classVersion The {@link ClassVersion} object to be transformed.
   * @param ownerId The owner this relation belongs to ({@link Repository} or {@link
   *     OntologyVersion}).
   * @return The resulting {@link Entity} object.
   */
  private Entity classVersionToEntity(ClassVersion classVersion, String ownerId) {
    Category entity;

    EntityType entityType =
        EntityType.fromValue(
            classVersion.getaClass().getTypes().stream()
                .findFirst()
                .orElseThrow(
                    () ->
                        new ResponseStatusException(
                            HttpStatus.INTERNAL_SERVER_ERROR,
                            "Class has no type and cannot be mapped to entity!")));

    Set<ClassVersion> superClasses =
        classVersionRepository.getCurrentSuperClassVersionsByOwnerId(
            classVersion.getaClass(), ownerId);

    if (entityType.equals(EntityType.CATEGORY)) {
      entity = new Category();
    } else if (entityType.equals(EntityType.PHENOTYPE_GROUP)) {
      entity = new PhenotypeGroup();
    } else {
      entity = new Phenotype();

      if (classVersion.getAnnotation("dataType").isPresent())
        ((Phenotype) entity)
            .setDataType(
                DataType.fromValue(classVersion.getAnnotation("dataType").get().getStringValue()));

      if (ApiModelMapper.isRestricted(entityType)) {
        superClasses.stream()
            .findFirst()
            .ifPresent(
                c -> {
                  String superType =
                      c.getaClass().getTypes().stream()
                          .findFirst()
                          .orElseThrow(
                              () ->
                                  new ResponseStatusException(
                                      HttpStatus.INTERNAL_SERVER_ERROR,
                                      "Super phenotype has no entity type!"));
                  ((Phenotype) entity)
                      .setSuperPhenotype(
                          (Phenotype)
                              new Phenotype()
                                  .id(c.getaClass().getId())
                                  .titles(
                                      c.getSortedAnnotations("title").stream()
                                          .map(
                                              a ->
                                                  new LocalisableText()
                                                      .text(a.getStringValue())
                                                      .lang(a.getLanguage()))
                                          .collect(Collectors.toList()))
                                  .entityType(EntityType.fromValue(superType)));
                });
        classVersion
            .getAnnotation("score")
            .ifPresent(s -> ((Phenotype) entity).setScore(BigDecimal.valueOf(s.getNumberValue())));
        classVersion
            .getAnnotation("restriction")
            .ifPresent(r -> ((Phenotype) entity).setRestriction(toRestriction(r)));
      } else {
        classVersion
            .getAnnotation("unit")
            .ifPresent(a -> ((Phenotype) entity).unit(ApiModelMapper.toUnit(a)));
      }

      classVersion
          .getAnnotation("expression")
          .ifPresent(a -> ((Phenotype) entity).setExpression(ApiModelMapper.toExpression(a)));
    }

    if (!ApiModelMapper.isRestricted(entityType))
      entity.setSuperCategories(
          superClasses.stream()
              .map(
                  c -> {
                    if (Objects.equals(c.getaClass().getId(), entity.getId())) return null;
                    return (Category)
                        new Category().id(c.getaClass().getId()).entityType(EntityType.CATEGORY);
                  })
              .filter(Objects::nonNull)
              .collect(Collectors.toList()));

    Repository repo =
        repositoryRepository
            .findById(classVersion.getaClass().getRepositoryId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));

    care.smith.top.backend.model.Repository repository =
        new care.smith.top.backend.model.Repository()
            .id(repo.getId())
            .name(repo.getName())
            .primary(repo.isPrimary());

    repo.getSuperDirectories().stream()
        .findFirst()
        .ifPresent(
            d -> repository.setOrganisation(new Organisation().id(d.getId()).name(d.getName())));

    entity.setRepository(repository);
    entity.setId(classVersion.getaClass().getId());
    entity.setVersion(classVersion.getVersion());
    entity.setEntityType(entityType);
    entity.setCreatedAt(classVersion.getCreatedAtOffset());
    entity.setAuthor(new UserAccount().username(classVersion.getUser()));

    PropertyAccessor accessor = PropertyAccessorFactory.forBeanPropertyAccess(entity);
    Arrays.asList("title", "synonym", "description")
        .forEach(
            p ->
                accessor.setPropertyValue(
                    p + "s",
                    classVersion.getSortedAnnotations(p).stream()
                        .map(
                            a ->
                                new LocalisableText()
                                    .text(a.getStringValue())
                                    .lang(a.getLanguage()))
                        .collect(Collectors.toList())));

    entity.setCodes(
        classVersion.getSortedAnnotations("code").stream()
            .map(ApiModelMapper::toCode)
            .filter(Objects::nonNull)
            .collect(Collectors.toList()));

    entity.setAuthor(new UserAccount().username(classVersion.getUser()));
    // TODO: entity.setRefer(); <- insert URI

    if (classVersion.getaClass().getSuperClassRelations() != null)
      classVersion.getaClass().getSuperClassRelations().stream()
          .findFirst()
          .ifPresent(sc -> entity.setIndex(sc.getIndex()));

    return entity;
  }

  /**
   * Recursively delete all annotations of an annotatable object and its annotations.
   *
   * @param annotatable Annotatable object of which annotations will be deleted.
   */
  private void deleteAnnotations(Annotatable annotatable) {
    annotatable.getAnnotations().forEach(this::deleteAnnotations);
    annotationRepository.deleteAll(annotatable.getAnnotations());
  }

  private void deleteClass(Class cls) {
    EntityType entityType =
        EntityType.fromValue(
            cls.getTypes().stream()
                .findFirst()
                .orElseThrow(
                    () ->
                        new ResponseStatusException(
                            HttpStatus.INTERNAL_SERVER_ERROR, "Entity has no entityType!")));

    if (ApiModelMapper.isCategory(entityType)) {
      classRepository.saveAll(
          classRepository
              .findSubclasses(cls.getId(), cls.getRepositoryId())
              .map(c -> classRepository.findById(c.getId()).orElse(null))
              .filter(Objects::nonNull)
              .peek(
                  c ->
                      c.setSuperClassRelations(
                              c.getSuperClassRelations().stream()
                                  .filter(
                                      r ->
                                          !r.getOwnerId().equals(cls.getRepositoryId())
                                              || !r.getSuperclass().getId().equals(cls.getId()))
                                  .collect(Collectors.toSet()))
                          .addSuperClassRelations(
                              cls.getSuperClassRelations().stream()
                                  .map(ClassRelation::clone)
                                  .collect(Collectors.toSet())))
              .collect(Collectors.toList()));
    }

    if (ApiModelMapper.isAbstract(entityType))
      classRepository.findSubclasses(cls.getId(), cls.getRepositoryId()).forEach(this::deleteClass);

    classVersionRepository.findAllByClassId(cls.getId()).forEach(this::deleteVersion);
    annotationRepository.deleteAll(
        annotationRepository.findAllByClassValueAndProperty(cls, "expression"));
    classRepository.delete(cls);
  }

  @Transactional
  private void deleteVersion(ClassVersion classVersion) {
    deleteAnnotations(classVersion);
    expressionRepository.deleteAll(classVersion.getExpressions());
    classVersionRepository.delete(classVersion);
  }

  private Annotation fromExpression(Expression expression, String repositoryId) {
    if (expression == null) return new Annotation("expression", null);

    if (expression.getEntityId() != null)
      return classRepository
          .findByIdAndRepositoryId(expression.getEntityId(), repositoryId)
          .map(aClass -> new Annotation("expression", aClass, null))
          .orElseGet(() -> new Annotation("expression", "class"));

    if (expression.getValue() != null) return ApiModelMapper.toAnnotation(expression.getValue());

    Annotation annotation = new Annotation("expression", expression.getFunction(), null);
    if (expression.getArguments() != null)
      annotation.addAnnotations(
          expression.getArguments().stream()
              .map(a -> fromExpression(a, repositoryId))
              .collect(Collectors.toList()));
    return annotation;
  }

  private Annotation fromRestriction(Restriction restriction) {
    if (restriction == null || restriction.getType() == null || restriction.getQuantor() == null)
      return null;

    Annotation annotation =
        (Annotation)
            new Annotation()
                .setProperty("restriction")
                .addAnnotation(new Annotation("type", restriction.getType().getValue(), null))
                .addAnnotation(new Annotation("negated", restriction.isNegated(), null))
                .addAnnotation(
                    new Annotation("quantor", restriction.getQuantor().getValue(), null));

    if (restriction instanceof NumberRestriction) {
      if (((NumberRestriction) restriction).getMinOperator() != null)
        annotation.addAnnotation(
            new Annotation(
                "minOperator",
                ((NumberRestriction) restriction).getMinOperator().getValue(),
                null));
      if (((NumberRestriction) restriction).getMaxOperator() != null)
        annotation.addAnnotation(
            new Annotation(
                "maxOperator",
                ((NumberRestriction) restriction).getMaxOperator().getValue(),
                null));
      if (((NumberRestriction) restriction).getValues() != null)
        annotation.addAnnotations(
            ((NumberRestriction) restriction)
                .getValues().stream()
                    .map(v -> new Annotation("value", v != null ? v.doubleValue() : null, null))
                    .collect(Collectors.toList()));
    } else if (restriction instanceof StringRestriction) {
      if (((StringRestriction) restriction).getValues() != null)
        annotation.addAnnotations(
            ((StringRestriction) restriction)
                .getValues().stream()
                    .filter(Objects::nonNull)
                    .map(v -> new Annotation("value", v, null))
                    .collect(Collectors.toList()));
    } else if (restriction instanceof DateTimeRestriction) {
      if (((DateTimeRestriction) restriction).getMinOperator() != null)
        annotation.addAnnotation(
            new Annotation(
                "minOperator",
                ((DateTimeRestriction) restriction).getMinOperator().getValue(),
                null));
      if (((DateTimeRestriction) restriction).getMaxOperator() != null)
        annotation.addAnnotation(
            new Annotation(
                "maxOperator",
                ((DateTimeRestriction) restriction).getMaxOperator().getValue(),
                null));
      if (((DateTimeRestriction) restriction).getValues() != null)
        annotation.addAnnotations(
            ((DateTimeRestriction) restriction)
                .getValues().stream()
                    .filter(Objects::nonNull)
                    .map(v -> new Annotation("value", v.toInstant(), null))
                    .collect(Collectors.toList()));
    } else if (restriction instanceof BooleanRestriction) {
      if (((BooleanRestriction) restriction).getValues() != null)
        annotation.addAnnotations(
            ((BooleanRestriction) restriction)
                .getValues().stream()
                    .map(v -> new Annotation("value", v, null))
                    .collect(Collectors.toList()));
    }

    return annotation;
  }

  private Stream<Entity> getChildren(String id, String ownerId) {
    return classRepository.findSubclasses(id, ownerId).map(child -> classToEntity(child, ownerId));
  }

  /**
   * Get {@link Repository} by repositoryId and directoryId. If the repository does not exist or is
   * not associated with the directory, this method will throw an exception.
   *
   * @param organisationId ID of the {@link Directory}
   * @param repositoryId ID of the {@link Repository}
   * @return The matching repository, if it exists.
   */
  private Repository getRepository(String organisationId, String repositoryId) {
    return repositoryRepository
        .findByIdAndSuperDirectoryId(repositoryId, organisationId)
        .orElseThrow(
            () ->
                new ResponseStatusException(
                    HttpStatus.NOT_FOUND,
                    String.format("Repository '%s' does not exist!", repositoryId)));
  }

  private Restriction toRestriction(Annotation annotation) {
    if (annotation == null) return null;
    if (annotation.getAnnotation("type").isEmpty()) return null;
    DataType type = DataType.fromValue(annotation.getAnnotation("type").get().getStringValue());

    Restriction restriction;

    if (type == DataType.STRING) {
      restriction = new StringRestriction();
      annotation
          .getSortedAnnotations("value")
          .forEach(v -> ((StringRestriction) restriction).addValuesItem(v.getStringValue()));
    } else if (type == DataType.NUMBER) {
      restriction = new NumberRestriction();
      annotation
          .getSortedAnnotations("value")
          .forEach(
              v ->
                  ((NumberRestriction) restriction)
                      .addValuesItem(
                          v.getNumberValue() != null
                              ? BigDecimal.valueOf(v.getNumberValue())
                              : null));
      annotation
          .getAnnotation("minOperator")
          .ifPresent(
              o ->
                  ((NumberRestriction) restriction)
                      .setMinOperator(RestrictionOperator.fromValue(o.getStringValue())));
      annotation
          .getAnnotation("maxOperator")
          .ifPresent(
              o ->
                  ((NumberRestriction) restriction)
                      .setMaxOperator(RestrictionOperator.fromValue(o.getStringValue())));
    } else if (type == DataType.DATE_TIME) {
      restriction = new DateTimeRestriction();
      annotation
          .getSortedAnnotations("value")
          .forEach(
              v ->
                  ((DateTimeRestriction) restriction)
                      .addValuesItem(v.getDateValue().atOffset(ZoneOffset.UTC)));
      annotation
          .getAnnotation("minOperator")
          .ifPresent(
              o ->
                  ((DateTimeRestriction) restriction)
                      .setMinOperator(RestrictionOperator.fromValue(o.getStringValue())));
      annotation
          .getAnnotation("maxOperator")
          .ifPresent(
              o ->
                  ((DateTimeRestriction) restriction)
                      .setMaxOperator(RestrictionOperator.fromValue(o.getStringValue())));
    } else if (type == DataType.BOOLEAN) {
      restriction = new BooleanRestriction();
      annotation
          .getSortedAnnotations("value")
          .forEach(v -> ((BooleanRestriction) restriction).addValuesItem(v.getBooleanValue()));
    } else return null;

    restriction.setType(type);
    annotation.getAnnotation("negated").ifPresent(a -> restriction.setNegated(a.getBooleanValue()));
    annotation
        .getAnnotation("quantor")
        .ifPresent(a -> restriction.setQuantor(Quantor.fromValue(a.getStringValue())));

    return restriction;
  }
}
